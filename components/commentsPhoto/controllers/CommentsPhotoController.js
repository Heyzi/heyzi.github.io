// Generated by CoffeeScript 1.7.1
'use strict';
CommentsPhotoModule.controller('CommentsPhotoController', function($scope, params, $stateParams, $timeout, RestModel, Loader, currentUser, friends) {
  $scope.params = params;
  $scope.window = window;
  $scope.loading = false;
  $scope.comments = [];
  $scope.result = false;
  $scope.count = 0;
  $scope.stopped = false;
  $scope.lookedItems = false;
  $scope.onlyCurrent = true;
  $scope.procent = 0;
  $scope.type = {};
  $scope.type.typeUsers = "all";
  $scope.userId = $stateParams.userId;
  $scope.currentUser = currentUser.response[0];
  $scope.countFriends = friends.response.count;
  $scope.userFriends = RestModel.isWorkingFriendsObject(friends);
  $scope.back = function() {
    $scope.stopped = true;
    if (Loader.ID !== null) {
      Loader.stopLoad();
    }
    return $scope.window.history.back();
  };
  $scope.allFriends = angular.copy($scope.userFriends);
  $scope.getComments = function(userFriends) {
    var scaningUsers;
    Loader.startLoad();
    $scope.isResultComments = [];
    $scope.result = false;
    $scope.stopped = false;
    $scope.procent = 0;
    $scope.count = 0;
    $scope.offset = 0;
    scaningUsers = RestModel.filteredUsers(userFriends, $scope.type.typeUsers);
    $scope.allCountUsers = scaningUsers.length;
    return $scope.searchCommentAmongUsers(scaningUsers);
  };
  $scope.searchCommentAmongUsers = function(users) {
    var checkedUser;
    checkedUser = users.splice(0, 1);
    $scope.comments = [];
    $scope.procent = 100 - Math.floor(users.length * 100 / $scope.allCountUsers);
    Loader.process($scope.procent);
    if (checkedUser.length > 0) {
      return $timeout(function() {
        return RestModel.getCommentsCount(checkedUser[0].id, $scope.params).then(function(data) {
          var count;
          if (!data.error) {
            count = data.response.count;
            if (count > 0) {
              return $scope.getCommentsOfCheckedUser(checkedUser, count, users);
            } else {
              return $scope.searchCommentAmongUsers(users);
            }
          } else {
            return $scope.searchCommentAmongUsers(users);
          }
        }, function(error) {
          console.log(error);
          return $scope.searchCommentAmongUsers(users);
        });
      }, 335);
    } else {
      return console.log('no');
    }
  };
  $scope.getCommentsOfCheckedUser = function(checkedUser, count, users) {
    if (count < 100) {
      return $timeout(function() {
        return RestModel.getCommentsCount(checkedUser[0].id, $scope.params, 100).then(function(data) {
          $scope.comments.push(data.response.items);
          $scope.offset = 0;
          return $scope.workingWithComment(checkedUser, $scope.comments, users);
        }, function(error) {
          console.log(error);
          return $scope.searchCommentAmongUsers(users);
        });
      }, 335);
    } else {
      $scope.arrayComments = [];
      return $timeout(function() {
        return RestModel.getCommentsCount(checkedUser[0].id, $scope.params, 100, $scope.offset).then(function(data) {
          $scope.comments.push(data.response.items);
          $scope.offset = $scope.offset + 100;
          count = count - 100;
          return $scope.getCommentsOfCheckedUser(checkedUser, count, users);
        }, function(error) {
          console.log(error);
          return $scope.searchCommentAmongUsers(users);
        });
      }, 335);
    }
  };
  $scope.workingWithComment = function(checkedUser, comments, users) {
    $scope.isResultComments.push({
      user: checkedUser,
      photosId: [],
      allComments: [],
      photos: {}
    });
    angular.forEach(comments, function(list) {
      return angular.forEach(list, function(comment) {
        if (comment.from_id === parseInt($scope.userId)) {
          $scope.isResultComments[$scope.count].photosId.push(comment.pid);
          comment.date = moment.unix(comment.date).format('DD.MM.YYYY HH:mm');
          return $scope.isResultComments[$scope.count].allComments.push(comment);
        }
      });
    });
    if ($scope.isResultComments[$scope.count].photosId.length > 0) {
      $scope.getPhotoWithComment($scope.isResultComments[$scope.count]).then(function(data) {
        $scope.isResultComments[$scope.count] = data;
        return $scope.count = $scope.count + 1;
      });
    } else {
      $scope.count = $scope.count + 1;
    }
    if ($scope.isResultComments.length > 0) {
      $scope.result = true;
    }
    if (users.length !== 0 && !$scope.stopped) {
      return $scope.searchCommentAmongUsers(users);
    } else {
      return Loader.stopLoad();
    }
  };
  $scope.getPhotoWithComment = function(object) {
    var oblectComments, oblectPhotosId, photosId;
    oblectPhotosId = {};
    oblectComments = {};
    angular.forEach(object.photosId, function(id, index) {
      return oblectPhotosId[id] = [];
    });
    angular.forEach(object.allComments, function(comment, index) {
      return oblectComments[comment.id] = comment;
    });
    photosId = '';
    angular.forEach(oblectPhotosId, function(item, key, index) {
      return photosId = photosId + object.user[0].id + '_' + key + ',';
    });
    photosId = photosId.slice(0, -1);
    return $timeout(function() {
      return RestModel.getPhotosById(photosId).then(function(data) {
        object.photos = data.response;
        angular.forEach(object.photos, function(photo) {
          photo.comments = [];
          return angular.forEach(oblectComments, function(comment) {
            if (photo.id === parseInt(comment.pid)) {
              return photo.comments.push(comment);
            }
          });
        });
        console.log(object);
        return object;
      }, function(error) {
        return console.log(error);
      });
    }, 335);
  };
  $scope.stopScan = function() {
    return $scope.stopped = true;
  };
  $scope.lookComments = function(photosComments, comments) {
    if (angular.isDefined(photosComments)) {
      $scope.lookedComments = photosComments;
      $scope.lookedOnlyComments = false;
    } else {
      $scope.lookedComments = false;
      $scope.lookedOnlyComments = comments;
    }
    $scope.lookedItems = true;
    $scope.offcet = window.pageYOffset;
    $('body').scrollTop(0);
    return true;
  };
  return $scope.lookAllCommentForPhoto = function(photo) {
    $scope.loading = true;
    return RestModel.getCommentsByPhoto(photo, $scope.params).then(function(comments) {
      $scope.onlyCurrent = false;
      angular.forEach(comments.response.profiles, function(profile) {
        return angular.forEach(comments.response.items, function(comment) {
          if (comment.from_id === parseInt(profile.id)) {
            comment.user = profile;
            return comment.date = moment.unix(comment.date).format('DD.MM.YYYY HH:mm');
          }
        });
      });
      $scope.loading = false;
      return $scope.all = comments.response.items;
    }, function(error) {
      return console.log(error);
    });
  };
});

//# sourceMappingURL=CommentsPhotoController.map
