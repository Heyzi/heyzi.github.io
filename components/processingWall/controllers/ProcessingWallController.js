// Generated by CoffeeScript 1.7.1
'use strict';
ProcessingWallModule.controller('ProcessingWallController', function($scope, $stateParams, $location, $timeout, RestModel, Loader, params, currentUser, friends) {
  $scope.params = params;
  $scope.window = window;
  $scope.loading = false;
  $scope.isLikes = [];
  $scope.result = false;
  $scope.count = 0;
  $scope.stopped = false;
  $scope.lookedItems = false;
  $scope.procent = 0;
  $scope.type = {};
  $scope.type.typeUsers = "all";
  $scope.userId = $stateParams.userId;
  $scope.currentUser = currentUser.response[0];
  $scope.countFriends = friends.response.count;
  $scope.userFriends = RestModel.isWorkingFriendsObject(friends);
  $scope.back = function() {
    $scope.stopped = true;
    if (Loader.ID !== null) {
      Loader.stopLoad();
    }
    return $scope.window.history.back();
  };
  $scope.allFriends = angular.copy($scope.userFriends);
  $scope.scanedWall = function() {
    var scaningUsers, userFriends;
    userFriends = angular.copy($scope.userFriends);
    Loader.startLoad();
    scaningUsers = [];
    $scope.isLikes = [];
    $scope.result = false;
    $scope.stopped = false;
    $scope.procent = 0;
    $scope.count = 0;
    scaningUsers = RestModel.filteredUsers(userFriends, $scope.type.typeUsers);
    $scope.allCountUsers = scaningUsers.length;
    return $scope.searchWallAmongUsers(scaningUsers);
  };
  $scope.searchWallAmongUsers = function(userFriends) {
    var checkedUser;
    checkedUser = userFriends.splice(0, 1);
    $scope.userWalls = [];
    $scope.userLikes = [];
    $scope.procent = 100 - Math.floor(userFriends.length * 100 / $scope.allCountUsers);
    Loader.process($scope.procent);
    if (checkedUser !== void 0) {
      return $timeout(function() {
        return RestModel.getWallPost(checkedUser[0].id, $scope.params, 100).then(function(data) {
          var walls;
          if (angular.isDefined(data.response && data.response.items)) {
            walls = data.response.items;
            if (walls.length === 0) {
              return $scope.searchWallAmongUsers(userFriends);
            } else {
              return $scope.getLikesFromsWalls(checkedUser, userFriends, walls);
            }
          } else {
            return $scope.searchWallAmongUsers(userFriends);
          }
        }, function(error) {
          console.log(error);
          return $scope.searchWallAmongUsers(userFriends);
        });
      }, 300);
    } else {
      return console.log('no');
    }
  };
  $scope.getLikesFromsWalls = function(checkedUser, userFriends, walls) {
    var tempWalls;
    tempWalls = '';
    if (walls.length < 25) {
      return $timeout(function() {
        return RestModel.getLikesExecute($scope.userId, walls, $scope.params, "post").then(function(likes) {
          $scope.userWalls.push(walls);
          $scope.userLikes.push(likes.response);
          return $scope.isSearchLikes(checkedUser, userFriends, $scope.userWalls, $scope.userLikes);
        }, function(error) {
          return console.log(error);
        });
      }, 300);
    } else {
      tempWalls = walls.splice(0, 24);
      return $timeout(function() {
        return RestModel.getLikesExecute($scope.userId, tempWalls, $scope.params, "post").then(function(likes) {
          $scope.userWalls.push(tempWalls);
          $scope.userLikes.push(likes.response);
          return $scope.getLikesFromsWalls(checkedUser, userFriends, walls);
        }, function(error) {
          return console.log(error);
        });
      }, 300);
    }
  };
  $scope.isSearchLikes = function(checkedUser, userFriends, userWalls, userLikes) {
    $scope.isLikes.push({
      user: checkedUser,
      walls: [],
      wallsCount: ''
    });
    angular.forEach(userLikes, function(likes) {
      return angular.forEach(likes, function(like, key) {
        var wallId;
        wallId = parseInt(key.replace(/\D+/g, ""));
        return angular.forEach(like.users, function(user) {
          if (user === parseInt($scope.userId)) {
            if (userWalls) {
              return $scope.addWallWithLike(checkedUser, wallId, userWalls);
            }
          }
        });
      });
    });
    if ($scope.isLikes.length > 0) {
      $scope.result = true;
    }
    $scope.count = $scope.count + 1;
    if (userFriends.length !== 0 && !$scope.stopped) {
      return $scope.searchWallAmongUsers(userFriends);
    } else {
      return Loader.stopLoad();
    }
  };
  $scope.addWallWithLike = function(checkedUser, wallId, userWalls) {
    var count;
    count = 0;
    angular.forEach(userWalls, function(walls) {
      count = count + walls.length;
      return angular.forEach(walls, function(wall) {
        if (wall.id === wallId) {
          wall.dateText = moment.unix(wall.date).format('DD.MM.YYYY HH:mm');
          return $scope.isLikes[$scope.count].walls.push(wall);
        }
      });
    });
    return $scope.isLikes[$scope.count].wallsCount = count;
  };
  $scope.sortableDateWall = function(a, b) {
    var oneTime, twoTime;
    oneTime = new Date(a.date).getTime();
    twoTime = new Date(b.date).getTime();
    return twoTime - oneTime;
  };
  $scope.sortableLastWall = function(a, b) {
    var oneTime, twoTime;
    oneTime = new Date(a.lastWall.date).getTime();
    twoTime = new Date(b.lastWall.date).getTime();
    return twoTime - oneTime;
  };
  $scope.sortingWall = function() {
    var tempArray;
    if ($scope.isLikes.length > 0) {
      tempArray = [];
      angular.forEach($scope.isLikes, function(item) {
        if (item.walls.length > 0) {
          item.walls.sort($scope.sortableDateWall);
          item.lastWall = {};
          item.lastWall = item.walls[0];
          return tempArray.push(item);
        }
      });
      if (tempArray.length > 0) {
        tempArray.sort($scope.sortableLastWall);
      }
      $scope.isLikes = null;
      return $scope.isLikes = tempArray;
    }
  };
  $scope.stopScanWall = function() {
    return $scope.stopped = true;
  };
  return $scope.lookLikesWalls = function(walls) {
    $scope.offcet = window.pageYOffset;
    $scope.lookWalls = walls;
    $scope.lookedItems = true;
    $('body').scrollTop(0);
    return true;
  };
});

//# sourceMappingURL=ProcessingWallController.map
